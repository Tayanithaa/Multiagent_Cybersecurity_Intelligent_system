"""
Malware Submission Handler
Handles user-uploaded malware samples for sandbox analysis
Machine 1 - Safe Zone (NO EXECUTION)
"""
import hashlib
import os
import aiofiles
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict
import aiohttp
import json


class MalwareSubmissionHandler:
    """
    Handle malware sample submissions from users
    CRITICAL: Never execute malware on this machine!
    """
    
    def __init__(self, quarantine_dir: str = "quarantine", dmz_api_url: Optional[str] = None):
        """
        Initialize submission handler
        
        Args:
            quarantine_dir: Directory for safe storage of malware samples
            dmz_api_url: URL of DMZ orchestrator (None if not yet configured)
        """
        self.quarantine_dir = Path(quarantine_dir)
        self.pending_dir = self.quarantine_dir / "pending"
        self.analyzed_dir = self.quarantine_dir / "analyzed"
        self.rejected_dir = self.quarantine_dir / "rejected"
        self.dmz_api_url = dmz_api_url or "http://localhost:5000"  # Default for development
        
        # Ensure directories exist
        self.pending_dir.mkdir(parents=True, exist_ok=True)
        self.analyzed_dir.mkdir(parents=True, exist_ok=True)
        self.rejected_dir.mkdir(parents=True, exist_ok=True)
    
    async def handle_upload(self, file_content: bytes, filename: str, user_id: str, 
                           db_connection) -> Dict[str, any]:
        """
        Handle malware sample upload from user
        
        Args:
            file_content: Raw file bytes
            filename: Original filename
            user_id: User who uploaded the file
            db_connection: Database connection for storing metadata
            
        Returns:
            Dictionary with task_id and status
        """
        # 1. Validate file
        validation_result = await self._validate_file(file_content, filename)
        if not validation_result['valid']:
            # Move to rejected directory
            await self._save_rejected(file_content, filename, validation_result['reason'])
            return {
                'status': 'rejected',
                'reason': validation_result['reason']
            }
        
        # 2. Calculate SHA256 hash (safe - no execution)
        file_hash = hashlib.sha256(file_content).hexdigest()
        
        # 3. Check if already analyzed
        existing = await self._check_existing_analysis(file_hash, db_connection)
        if existing:
            return {
                'status': 'already_analyzed',
                'task_id': file_hash,
                'result': existing
            }
        
        # 4. Save to quarantine (read-only storage)
        quarantine_path = self.pending_dir / file_hash
        async with aiofiles.open(quarantine_path, 'wb') as f:
            await f.write(file_content)
        
        # Make file read-only to prevent accidental execution
        os.chmod(quarantine_path, 0o444)
        
        # 5. Store metadata in database
        metadata = {
            'file_hash': file_hash,
            'original_filename': filename,
            'file_size': len(file_content),
            'user_id': user_id,
            'upload_timestamp': datetime.utcnow().isoformat(),
            'status': 'queued',
            'quarantine_path': str(quarantine_path)
        }
        
        await self._store_metadata(metadata, db_connection)
        
        # 6. Send to DMZ for analysis (if configured)
        dmz_status = await self._send_to_dmz(file_hash, str(quarantine_path))
        
        return {
            'status': 'queued',
            'task_id': file_hash,
            'estimated_time': '5-10 minutes',
            'dmz_status': dmz_status
        }
    
    async def _validate_file(self, file_content: bytes, filename: str) -> Dict[str, any]:
        """
        Validate uploaded file
        """
        # Check file size (max 100MB)
        max_size = 100 * 1024 * 1024  # 100MB
        if len(file_content) > max_size:
            return {
                'valid': False,
                'reason': f'File too large (max {max_size // (1024*1024)}MB)'
            }
        
        # Check minimum size (at least 1KB)
        if len(file_content) < 1024:
            return {
                'valid': False,
                'reason': 'File too small (min 1KB)'
            }
        
        # Check if file is empty
        if len(file_content) == 0:
            return {
                'valid': False,
                'reason': 'Empty file'
            }
        
        return {'valid': True}
    
    async def _check_existing_analysis(self, file_hash: str, db_connection) -> Optional[Dict]:
        """
        Check if this file has already been analyzed
        """
        try:
            # Query database for existing analysis
            query = """
                SELECT * FROM malware_analysis 
                WHERE file_hash = ? 
                ORDER BY analysis_timestamp DESC 
                LIMIT 1
            """
            result = await db_connection.fetch_one(query, (file_hash,))
            
            if result:
                return dict(result)
            return None
        except Exception as e:
            print(f"Error checking existing analysis: {e}")
            return None
    
    async def _store_metadata(self, metadata: Dict, db_connection):
        """
        Store submission metadata in database
        """
        try:
            query = """
                INSERT INTO malware_submissions 
                (file_hash, original_filename, file_size, user_id, upload_timestamp, status, quarantine_path)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """
            await db_connection.execute(
                query,
                (
                    metadata['file_hash'],
                    metadata['original_filename'],
                    metadata['file_size'],
                    metadata['user_id'],
                    metadata['upload_timestamp'],
                    metadata['status'],
                    metadata['quarantine_path']
                )
            )
        except Exception as e:
            print(f"Error storing metadata: {e}")
            raise
    
    async def _send_to_dmz(self, file_hash: str, file_path: str) -> str:
        """
        Send analysis request to DMZ orchestrator
        Returns status string
        """
        try:
            async with aiohttp.ClientSession() as session:
                payload = {
                    'file_hash': file_hash,
                    'file_path': file_path,
                    'priority': 'normal',
                    'timestamp': datetime.utcnow().isoformat()
                }
                
                async with session.post(
                    f"{self.dmz_api_url}/api/submit_analysis",
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        return f"dmz_accepted: {result.get('task_id')}"
                    else:
                        return f"dmz_error: HTTP {response.status}"
        
        except aiohttp.ClientConnectorError:
            # DMZ not configured yet - this is expected during development
            return "dmz_not_configured"
        except Exception as e:
            return f"dmz_error: {str(e)}"
    
    async def _save_rejected(self, file_content: bytes, filename: str, reason: str):
        """
        Save rejected file to rejected directory with reason
        """
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        rejected_path = self.rejected_dir / f"{timestamp}_{filename}"
        
        async with aiofiles.open(rejected_path, 'wb') as f:
            await f.write(file_content)
        
        # Save rejection reason
        reason_path = rejected_path.with_suffix('.txt')
        async with aiofiles.open(reason_path, 'w') as f:
            await f.write(f"Rejection Reason: {reason}\n")
            await f.write(f"Timestamp: {datetime.utcnow().isoformat()}\n")
    
    async def get_submission_status(self, task_id: str, db_connection) -> Optional[Dict]:
        """
        Get status of submitted malware sample
        
        Args:
            task_id: File hash (task ID)
            db_connection: Database connection
            
        Returns:
            Status dictionary or None if not found
        """
        try:
            query = """
                SELECT * FROM malware_submissions 
                WHERE file_hash = ?
            """
            result = await db_connection.fetch_one(query, (task_id,))
            
            if result:
                return dict(result)
            return None
        except Exception as e:
            print(f"Error getting submission status: {e}")
            return None
